// Copyright (c) 2018 Bhojpur Consulting Private Limited, India. All rights reserved.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by main. DO NOT EDIT.

package v1

import (
	"context"
	"time"

	v1 "github.com/bhojpur/host/pkg/apis/bke.bhojpur.net/v1"
	"github.com/bhojpur/host/pkg/common/apply"
	"github.com/bhojpur/host/pkg/common/condition"
	"github.com/bhojpur/host/pkg/common/generic"
	"github.com/bhojpur/host/pkg/common/kv"
	"github.com/bhojpur/host/pkg/labni/client"
	"github.com/bhojpur/host/pkg/labni/controller"
	"k8s.io/apimachinery/pkg/api/equality"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/tools/cache"
)

type BKEClusterHandler func(string, *v1.BKECluster) (*v1.BKECluster, error)

type BKEClusterController interface {
	generic.ControllerMeta
	BKEClusterClient

	OnChange(ctx context.Context, name string, sync BKEClusterHandler)
	OnRemove(ctx context.Context, name string, sync BKEClusterHandler)
	Enqueue(namespace, name string)
	EnqueueAfter(namespace, name string, duration time.Duration)

	Cache() BKEClusterCache
}

type BKEClusterClient interface {
	Create(*v1.BKECluster) (*v1.BKECluster, error)
	Update(*v1.BKECluster) (*v1.BKECluster, error)
	UpdateStatus(*v1.BKECluster) (*v1.BKECluster, error)
	Delete(namespace, name string, options *metav1.DeleteOptions) error
	Get(namespace, name string, options metav1.GetOptions) (*v1.BKECluster, error)
	List(namespace string, opts metav1.ListOptions) (*v1.BKEClusterList, error)
	Watch(namespace string, opts metav1.ListOptions) (watch.Interface, error)
	Patch(namespace, name string, pt types.PatchType, data []byte, subresources ...string) (result *v1.BKECluster, err error)
}

type BKEClusterCache interface {
	Get(namespace, name string) (*v1.BKECluster, error)
	List(namespace string, selector labels.Selector) ([]*v1.BKECluster, error)

	AddIndexer(indexName string, indexer BKEClusterIndexer)
	GetByIndex(indexName, key string) ([]*v1.BKECluster, error)
}

type BKEClusterIndexer func(obj *v1.BKECluster) ([]string, error)

type bKEClusterController struct {
	controller    controller.SharedController
	client        *client.Client
	gvk           schema.GroupVersionKind
	groupResource schema.GroupResource
}

func NewBKEClusterController(gvk schema.GroupVersionKind, resource string, namespaced bool, controller controller.SharedControllerFactory) BKEClusterController {
	c := controller.ForResourceKind(gvk.GroupVersion().WithResource(resource), gvk.Kind, namespaced)
	return &bKEClusterController{
		controller: c,
		client:     c.Client(),
		gvk:        gvk,
		groupResource: schema.GroupResource{
			Group:    gvk.Group,
			Resource: resource,
		},
	}
}

func FromBKEClusterHandlerToHandler(sync BKEClusterHandler) generic.Handler {
	return func(key string, obj runtime.Object) (ret runtime.Object, err error) {
		var v *v1.BKECluster
		if obj == nil {
			v, err = sync(key, nil)
		} else {
			v, err = sync(key, obj.(*v1.BKECluster))
		}
		if v == nil {
			return nil, err
		}
		return v, err
	}
}

func (c *bKEClusterController) Updater() generic.Updater {
	return func(obj runtime.Object) (runtime.Object, error) {
		newObj, err := c.Update(obj.(*v1.BKECluster))
		if newObj == nil {
			return nil, err
		}
		return newObj, err
	}
}

func UpdateBKEClusterDeepCopyOnChange(client BKEClusterClient, obj *v1.BKECluster, handler func(obj *v1.BKECluster) (*v1.BKECluster, error)) (*v1.BKECluster, error) {
	if obj == nil {
		return obj, nil
	}

	copyObj := obj.DeepCopy()
	newObj, err := handler(copyObj)
	if newObj != nil {
		copyObj = newObj
	}
	if obj.ResourceVersion == copyObj.ResourceVersion && !equality.Semantic.DeepEqual(obj, copyObj) {
		return client.Update(copyObj)
	}

	return copyObj, err
}

func (c *bKEClusterController) AddGenericHandler(ctx context.Context, name string, handler generic.Handler) {
	c.controller.RegisterHandler(ctx, name, controller.SharedControllerHandlerFunc(handler))
}

func (c *bKEClusterController) AddGenericRemoveHandler(ctx context.Context, name string, handler generic.Handler) {
	c.AddGenericHandler(ctx, name, generic.NewRemoveHandler(name, c.Updater(), handler))
}

func (c *bKEClusterController) OnChange(ctx context.Context, name string, sync BKEClusterHandler) {
	c.AddGenericHandler(ctx, name, FromBKEClusterHandlerToHandler(sync))
}

func (c *bKEClusterController) OnRemove(ctx context.Context, name string, sync BKEClusterHandler) {
	c.AddGenericHandler(ctx, name, generic.NewRemoveHandler(name, c.Updater(), FromBKEClusterHandlerToHandler(sync)))
}

func (c *bKEClusterController) Enqueue(namespace, name string) {
	c.controller.Enqueue(namespace, name)
}

func (c *bKEClusterController) EnqueueAfter(namespace, name string, duration time.Duration) {
	c.controller.EnqueueAfter(namespace, name, duration)
}

func (c *bKEClusterController) Informer() cache.SharedIndexInformer {
	return c.controller.Informer()
}

func (c *bKEClusterController) GroupVersionKind() schema.GroupVersionKind {
	return c.gvk
}

func (c *bKEClusterController) Cache() BKEClusterCache {
	return &bKEClusterCache{
		indexer:  c.Informer().GetIndexer(),
		resource: c.groupResource,
	}
}

func (c *bKEClusterController) Create(obj *v1.BKECluster) (*v1.BKECluster, error) {
	result := &v1.BKECluster{}
	return result, c.client.Create(context.TODO(), obj.Namespace, obj, result, metav1.CreateOptions{})
}

func (c *bKEClusterController) Update(obj *v1.BKECluster) (*v1.BKECluster, error) {
	result := &v1.BKECluster{}
	return result, c.client.Update(context.TODO(), obj.Namespace, obj, result, metav1.UpdateOptions{})
}

func (c *bKEClusterController) UpdateStatus(obj *v1.BKECluster) (*v1.BKECluster, error) {
	result := &v1.BKECluster{}
	return result, c.client.UpdateStatus(context.TODO(), obj.Namespace, obj, result, metav1.UpdateOptions{})
}

func (c *bKEClusterController) Delete(namespace, name string, options *metav1.DeleteOptions) error {
	if options == nil {
		options = &metav1.DeleteOptions{}
	}
	return c.client.Delete(context.TODO(), namespace, name, *options)
}

func (c *bKEClusterController) Get(namespace, name string, options metav1.GetOptions) (*v1.BKECluster, error) {
	result := &v1.BKECluster{}
	return result, c.client.Get(context.TODO(), namespace, name, result, options)
}

func (c *bKEClusterController) List(namespace string, opts metav1.ListOptions) (*v1.BKEClusterList, error) {
	result := &v1.BKEClusterList{}
	return result, c.client.List(context.TODO(), namespace, result, opts)
}

func (c *bKEClusterController) Watch(namespace string, opts metav1.ListOptions) (watch.Interface, error) {
	return c.client.Watch(context.TODO(), namespace, opts)
}

func (c *bKEClusterController) Patch(namespace, name string, pt types.PatchType, data []byte, subresources ...string) (*v1.BKECluster, error) {
	result := &v1.BKECluster{}
	return result, c.client.Patch(context.TODO(), namespace, name, pt, data, result, metav1.PatchOptions{}, subresources...)
}

type bKEClusterCache struct {
	indexer  cache.Indexer
	resource schema.GroupResource
}

func (c *bKEClusterCache) Get(namespace, name string) (*v1.BKECluster, error) {
	obj, exists, err := c.indexer.GetByKey(namespace + "/" + name)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, errors.NewNotFound(c.resource, name)
	}
	return obj.(*v1.BKECluster), nil
}

func (c *bKEClusterCache) List(namespace string, selector labels.Selector) (ret []*v1.BKECluster, err error) {

	err = cache.ListAllByNamespace(c.indexer, namespace, selector, func(m interface{}) {
		ret = append(ret, m.(*v1.BKECluster))
	})

	return ret, err
}

func (c *bKEClusterCache) AddIndexer(indexName string, indexer BKEClusterIndexer) {
	utilruntime.Must(c.indexer.AddIndexers(map[string]cache.IndexFunc{
		indexName: func(obj interface{}) (strings []string, e error) {
			return indexer(obj.(*v1.BKECluster))
		},
	}))
}

func (c *bKEClusterCache) GetByIndex(indexName, key string) (result []*v1.BKECluster, err error) {
	objs, err := c.indexer.ByIndex(indexName, key)
	if err != nil {
		return nil, err
	}
	result = make([]*v1.BKECluster, 0, len(objs))
	for _, obj := range objs {
		result = append(result, obj.(*v1.BKECluster))
	}
	return result, nil
}

type BKEClusterStatusHandler func(obj *v1.BKECluster, status v1.BKEClusterStatus) (v1.BKEClusterStatus, error)

type BKEClusterGeneratingHandler func(obj *v1.BKECluster, status v1.BKEClusterStatus) ([]runtime.Object, v1.BKEClusterStatus, error)

func RegisterBKEClusterStatusHandler(ctx context.Context, controller BKEClusterController, condition condition.Cond, name string, handler BKEClusterStatusHandler) {
	statusHandler := &bKEClusterStatusHandler{
		client:    controller,
		condition: condition,
		handler:   handler,
	}
	controller.AddGenericHandler(ctx, name, FromBKEClusterHandlerToHandler(statusHandler.sync))
}

func RegisterBKEClusterGeneratingHandler(ctx context.Context, controller BKEClusterController, apply apply.Apply,
	condition condition.Cond, name string, handler BKEClusterGeneratingHandler, opts *generic.GeneratingHandlerOptions) {
	statusHandler := &bKEClusterGeneratingHandler{
		BKEClusterGeneratingHandler: handler,
		apply:                       apply,
		name:                        name,
		gvk:                         controller.GroupVersionKind(),
	}
	if opts != nil {
		statusHandler.opts = *opts
	}
	controller.OnChange(ctx, name, statusHandler.Remove)
	RegisterBKEClusterStatusHandler(ctx, controller, condition, name, statusHandler.Handle)
}

type bKEClusterStatusHandler struct {
	client    BKEClusterClient
	condition condition.Cond
	handler   BKEClusterStatusHandler
}

func (a *bKEClusterStatusHandler) sync(key string, obj *v1.BKECluster) (*v1.BKECluster, error) {
	if obj == nil {
		return obj, nil
	}

	origStatus := obj.Status.DeepCopy()
	obj = obj.DeepCopy()
	newStatus, err := a.handler(obj, obj.Status)
	if err != nil {
		// Revert to old status on error
		newStatus = *origStatus.DeepCopy()
	}

	if a.condition != "" {
		if errors.IsConflict(err) {
			a.condition.SetError(&newStatus, "", nil)
		} else {
			a.condition.SetError(&newStatus, "", err)
		}
	}
	if !equality.Semantic.DeepEqual(origStatus, &newStatus) {
		if a.condition != "" {
			// Since status has changed, update the lastUpdatedTime
			a.condition.LastUpdated(&newStatus, time.Now().UTC().Format(time.RFC3339))
		}

		var newErr error
		obj.Status = newStatus
		newObj, newErr := a.client.UpdateStatus(obj)
		if err == nil {
			err = newErr
		}
		if newErr == nil {
			obj = newObj
		}
	}
	return obj, err
}

type bKEClusterGeneratingHandler struct {
	BKEClusterGeneratingHandler
	apply apply.Apply
	opts  generic.GeneratingHandlerOptions
	gvk   schema.GroupVersionKind
	name  string
}

func (a *bKEClusterGeneratingHandler) Remove(key string, obj *v1.BKECluster) (*v1.BKECluster, error) {
	if obj != nil {
		return obj, nil
	}

	obj = &v1.BKECluster{}
	obj.Namespace, obj.Name = kv.RSplit(key, "/")
	obj.SetGroupVersionKind(a.gvk)

	return nil, generic.ConfigureApplyForObject(a.apply, obj, &a.opts).
		WithOwner(obj).
		WithSetID(a.name).
		ApplyObjects()
}

func (a *bKEClusterGeneratingHandler) Handle(obj *v1.BKECluster, status v1.BKEClusterStatus) (v1.BKEClusterStatus, error) {
	if !obj.DeletionTimestamp.IsZero() {
		return status, nil
	}

	objs, newStatus, err := a.BKEClusterGeneratingHandler(obj, status)
	if err != nil {
		return newStatus, err
	}

	return newStatus, generic.ConfigureApplyForObject(a.apply, obj, &a.opts).
		WithOwner(obj).
		WithSetID(a.name).
		ApplyObjects(objs...)
}
